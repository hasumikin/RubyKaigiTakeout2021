= PRK Firmware

: subtitle
   Keyboard is\nEssentially Ruby
: author
   Hitoshi HASUMI
: place
   RubyKaigi Takeout 2021  |  Sep 10th
: allotted-time
   25m
: theme
   theme

= Acknowledgement
  # image
  # src = images/kakutani.png
  # relative_height = 103
  # relative_margin_top = 0

= Acknowledgement
  # blockquote
  # title = YOU COULD SAY DIY-KEYBOARD IS ESSENTIALLY RUBY
  (('tag:center'))\n\n‚ÄúYou are able to build ((*Ruby*)) by yourself‚Äù\n\n\n

= Acknowledgement
  # blockquote
  # title = YOU COULD SAY DIY-KEYBOARD IS ESSENTIALLY RUBY
  (('tag:center'))\n\n‚ÄúYou are able to build a ((*keyboard*)) by yourself‚Äù\n\n\n

= Acknowledgement
  # blockquote
  # title = YOU COULD SAY DIY-KEYBOARD IS ESSENTIALLY RUBY
  (('tag:center'))\n‚ÄúYOU COULD SAY\nDIY-KEYBOARD IS\nESSENTIALLY ((*RUBY*))‚Äù\n\n

= Exactly one year ago
  # image
  # src = images/kakutani_1.jpg
  # relative_height = 103
  # relative_margin_top = 0

= Exactly one year ago
  # image
  # src = images/kakutani_2.jpg
  # relative_height = 103
  # relative_margin_top = 0

= Keyboard firmware ... language
* QMK Firmware ... C
* KMK Firmware ... Python
* PRK Firmware ... Ruby
* If you want GUI (extendibility?)
  * VIA, REMAP, Kiibohd Firmware

= Keyboard firmware ... repository
  # image
  # src = images/qmk_kmk_prk.png
  # relative_height = 103
  # relative_margin_top = 0

= Keyboard firmware ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
  # image
  # src = images/qmk_kmk_prk_2.png
  # relative_height = 103
  # relative_margin_top = 0

= PRK Firmware - How to start [hardware]
  * Buy a DIY Keyboard kit
    * Which uses ((*Pro Micro*))
  * Pro Micro?
    * Arduino compatible board
  * PRK Firmware ((*doesn't*)) work on\n"normal" Pro Micro (ATMega 32U4)

  # image
  # src = images/promicro.jpg
  # align = right
  # relative-height = 81
  # relative_margin_left = 10

(('tag:right'))
(('tag:xx-small:https://www.switch-science.com/catalog/3914/'))

= PRK Firmware - How to start [hardware]
  * Instead, choose\n((*SPARKFUN PRO MICRO - RP2040*))\n((*[model no. DEV-17717]*))

  # image
  # src = images/promicro_rp2040.jpg
  # align = right
  # relative-height = 85
  # relative_margin_left = 10

(('tag:right'))\n\n\n
(('tag:xx-small:https://www.sparkfun.com/products/17717'))

= PRK Firmware - How to start [hardware]
  * RP2040?
    * "Raspberry Silicon"
    * Implemented on Raspberry Pi Pico
    * The target chip of ((*PRK Firmware*))

  # image
  # src = images/rpi_pico.jpg
  # align = right
  # relative-height = 100
  # relative_margin_left = 2

(('tag:right'))\n\n
(('tag:xx-small:https://pc.watch.impress.co.jp/docs/news/1301670.html'))

= PRK Firmware - How to start [software]
  * Build environment
    * macOS, Linux, Windows + WSL
  * Prerequisites
    * cmake
    * github.com/raspberrypi/pico-sdk

= PRK Firmware - How to start [software]
  # enscript bash
  $ git clone --recursive https://github.com/picoruby/prk_firmware.git
  $ cd prk_firmware/keyboards
  $ git clone https://github.com/picoruby/prk_crkbd.git
  $ cd prk_crkbd/build
  $ cmake ../../..    # ../../../CMakeLists.txt
  $ make
  $ ls -l prk_firmware.*
  -rwxr-xr-x (...) prk_firmware.bin
  -rw-r--r-- (...) prk_firmware.dis
  -rwxr-xr-x (...) prk_firmware.elf
  -rw-r--r-- (...) prk_firmware.elf.map
  -rw-r--r-- (...) prk_firmware.hex
  -rw-r--r-- (...) prk_firmware.uf2   üëàüëàüëàüëàüëàüëàüëàüëàüëà

= PRK Firmware - How to start [software]
  * Connect USB cable while\npressing "boot button"
  * RPI-RP2 will be mounted, then

  # image
  # align = right
  # src = images/boot_button_1.png
  # relative-height = 83
  # relative_margin_left = 5
  # relative_margin_top = -3

(('tag:right'))
(('tag:xx-small'))\n\n\n\n\n
https://www.raspberrypi.org/documentation/rp2040/getting-started

= PRK Firmware - How to start [software]
  # image
  # src = images/drag_and_drop_1.png
  # relative-height = 100

= PRK Firmware - How to start [software]
  # image
  # src = images/promicro_rp2040_boot_button.png
  # relative-height = 90

= Troubleshooting of Pro Micro RP2040
  * Logic level (depending on PCB)
    * Pro Micro RP2040 -> 3.3V
    * Pro Micro ATMega -> 5V
    * Just avoid "Gherkin Pro Micro ver."
  * Shortage of conthrough's height\nif you build an "upside down" keyboard
    * Use XB-3-6-6P on akizukidenshi.com

  # image
  # src = images/shortage.png
  # align = right
  # relative-height = 90
  # relative_margin_left = 9

= Troubleshooting of Pro Micro RP2040
  * You can't push "boot button"\non an"upside down" keyboard
    * Have to detach Pro Micro\nevery time flashing a firmware üò´

  # image
  # src = images/crkbd.jpg
  # align = right
  # relative-height = 85
  # relative_margin_left = 11

= Troubleshooting of Pro Micro RP2040
  * You can't push "boot button"\non an"upside down" keyboard
    * Have to detach Pro Micro\nevery time flashing a firmware üò´

  # image
  # src = images/crkbd.jpg
  # align = right
  # relative-height = 85
  # relative_margin_left = 11

(('tag:center'))(('tag:large'))
((*Don't worry, I will have a soluiton!\n(disscussed later)*))

= PRK Firmware - How to start
  * Ask Rubyists on Twitter
    * @takkanm
    * @swan_match
    * @kakutani
    * @hasumikin (me), etc.
  * Join #keyboard in ruby-jp Slack

= e.g.) picoruby/prk_pipigherkin
  * Gherkin for\nthe Raspberry Pi Pico
    * PCB available\non talpkeyboard.net
    * Easy to explain but\nhard for newbies to build

  # image
  # src = images/pipi_gherkin.jpg
  # align = right
  # relative-height = 80
  # relative_margin_top = -3
  # relative_margin_left = 8

(('tag:right'))
(('tag:xx-small:https://www.40percent.club/2021/02/pipi-gherkin.html'))

= e.g.) prk_pipigherkin/keymap.rb
  # enscript ruby
  # Initialize Keyboard
  kbd = Keyboard.new
  # Initialize GPIO pins
  kbd.init_pins(
    [ 12, 11, 10, 9, 8 ], # row0, row1,... respectively
    [ 7, 6, 5, 4, 3, 2 ]  # col0, col1,... respectively
  )
  # Default keymap
  kbd.add_layer :default, %i(
    KC_Q   KC_W   KC_E   KC_R   KC_T      KC_Y      KC_U   KC_I   KC_O   KC_P
    KC_A   KC_S   KC_D   KC_F   KC_G      KC_H      KC_J   KC_K   KC_L   KC_BSPACE
    Z_LSFT X_LGUI C_LALT V_LCTL SPC_LOWER ENT_RAISE B_RCTL N_RALT M_RGUI UNDS_RSFT
  )
  # Mode keys
  kbd.define_mode_key :Z_LSFT,    [ :KC_Z,     :KC_LSFT, 150, 150 ]
  # ...
  kbd.define_mode_key :UNDS_RSFT, [ :KC_UNDS,  :KC_RSFT, 150, 150 ]
  kbd.define_mode_key :ENT_RAISE, [ :KC_ENTER, :raise,   150, 150 ]
  kbd.define_mode_key :SPC_LOWER, [ :KC_SPACE, :lower,   150, 150 ]

= e.g.) prk_pipigherkin/keymap.rb
  kbd.add_layer :raise, %i(
    KC_EXLM   KC_AT     KC_HASH     KC_DLR    KC_PERC    KC_CIRC    KC_AMPR   KC_ASTER  KC_EQUAL  KC_PLUS
    KC_LABK   KC_LCBR   KC_LBRACKET KC_LPRN   KC_MINUS   KC_LEFT    KC_DOWN   KC_UP     KC_RIGHT  KC_BSPACE
    KC_RABK   KC_RCBR   KC_RBRACKET KC_RPRN   ADJUST     ENT_RAISE  KC_BSLASH KC_COMMA  KC_DOT    KC_SLASH
  )
  kbd.add_layer :lower, %i(
    KC_1      KC_2      KC_3        KC_4      KC_5       KC_6       KC_7      KC_8      KC_9      KC_0
    KC_TAB    KC_NO     KC_QUOTE    KC_DQUO   KC_MINUS   KC_GRAVE   KC_TILD   KC_PIPE   KC_COLON  KC_SCOLON
    KC_ESCAPE KC_LGUI   KC_LALT     KC_LCTL   SPC_LOWER  ADJUST     KC_RCTL   KC_RALT   KC_RGUI   KC_RSFT
  )

= e.g.) picoruby/prk_crkbd
  # image
  # src = images/crkbd_2.jpg
  # relative_height = 95

= e.g.) prk_crkbd/keymap.rb
  # enscript ruby
  #
  kbd = Keyboard.new
  # (init_pins, add_layer etc., then)
  rgb = RGB.new(
    0,    # pin number
    6,    # size of underglow LED
    21    # size of backlight LED
  )
  rgb.effect = :rainbow # or :breathing
  kbd.append rgb
  kbd.start!

= e.g.) prk_crkbd/keymap.rb
\n
If you wanna input "((*;*))" with SHIFT and "((*:*))" without SHIFT,

  # enscript ruby
  kbd.before_report do
    kbd.invert_sft if kbd.keys_include?(:KC_SCOLON)
  end

(('tag:center'))
You no longer need to modify .vimrc

= You can write invert_ctl in keymap.rb
  # enscript ruby
  class Keyboard
    def invert_ctl
      #      KC_LCTL: 0b00000001
      #      KC_LSFT: 0b00000010
      #      KC_LALT: 0b00000100
      #      KC_LGUI: 0b00001000
      #      KC_RCTL: 0b00010000
      #      KC_RSFT: 0b00100000
      #      KC_RALT: 0b01000000
      #      KC_RGUI: 0b10000000
      if (@modifier & 0b00010001) > 0
         @modifier &= 0b11101110
      else
         @modifier |= 0b00000001
      end
    end
  end
  kbd.before_report do
    kbd.invert_ctl if kbd.keys_include?(:KC_V)
  end

= Fibonacci
(('tag:center'))\n\n\n
(DEMO)

= Fibonacci
  # enscript c
  1
  2
  3
  5
  8
  13
  21
  34
  55
  89
  144
  233
  377
  ....

= Fibonacci in keymap.rb
  # enscript ruby
  class Fibonacci
    def initialize
      # (Ommitting F0 and F1)
      @a = 0 ; @b = 1
    end
    def take
      result = @a + @b
      @a = @b
      @b = result
    end
  end
  fibonacci = Fibonacci.new
  kbd.define_mode_key :FIBONACCI,
                      [ Proc.new { kbd.macro fibonacci.take },
                      :KC_NO, 300, nil ]

= Technology behind PRK Firmware
  * Static type check by "steep" gem
    * Super helpful to notice a trivial mistake before\ninstalling an executable into an actual Pro Micro

  $ cd keyboard/prk_crkbd/build ; make
  # Type checking files:
  ......................................................................
  No type error detected. üçµ

= Technology behind PRK Firmware
  * PicoRuby compiler
  # image
  # src = images/architecture_1.png
  # relative_height = 100
  # relative_margin_top = -4

= Technology behind PRK Firmware
  * PicoRuby
    * PicoRuby compiler + mruby/c VM
    * Ruby Association Grant\nhttps://www.ruby.or.jp/ja/news/20210715
  # image
  # src = images/QR_raactivityreport.png
  # relative_height = 90

= Future work
  * Compiling `keymap.rb` on the fly
    * ((*Drag and drop*)) keymap.rb\n(like CircuitPython)
    * pico-sdk will be ((*no longer*)) needed
    * Will solve even the\n((*"boot button issue"*)) üéä

  # image
  # src = images/drag_and_drop_2.png
  # align = right
  # relative-height = 100
  # relative_margin_left = 3

= Future work
* ((*IRB*)) on microcontroller
* `picoruby` in ((*ruby-build*))
* PicoRuby compiler (((*picorbc*))) as\nan alternative compiler of mruby

= ((* *))
(('tag:center'))\n\n\n
(('tag:large:By the way,'))
== prop
: hide-title
   true

= ((* *))
(('tag:center'))\n\n
(('tag:large'))
((*What do you think is\n
the No.1 text editor?*))
== prop
: hide-title
   true

= ((* *))
(('tag:center'))\n\n\n
(('tag:large:vim?'))
== prop
: hide-title
   true

= ((* *))
(('tag:center'))\n\n\n
(('tag:large:emacs?'))
== prop
: hide-title
   true

= ((* *))
(('tag:center'))\n\n\n
(('tag:large:textbringer?'))
== prop
: hide-title
   true

= ((* *))
  # image
  # src = images/matamata.png
  # relative_height = 80
  # relative_margin_top = 5
  # relative_margin_left = -9
== prop
: hide-title
   true

= ((* *))
\n\n\n\n
Copyright ¬© Microsoft
  # image
  # src = images/Notepad.png
  # align = right
  # relative-height = 100
  # relative_margin_left = 10
== prop
: hide-title
   true

= ((* *))
\n\n\n\n
Copyright ¬© Apple Inc.
  # image
  # src = images/textedit.png
  # align = right
  # relative-height = 100
  # relative_margin_left = 10
== prop
: hide-title
   true

= PicoRuby Compiler on Board
(('tag:center'))\n\n
(DEMO)

= PicoRuby Compiler on Board
* TODO eval

= ((* *))
(('tag:center'))\n
(('tag:xx-large'))
So,
== prop
: hide-title
   true

= ((* *))
(('tag:center'))\n
(('tag:xx-large'))
You could say
== prop
: hide-title
   true

= ((* *))
(('tag:center'))
(('tag:xx-large'))
Keyboard is\n
Essentially\n
((*Ruby*))
== prop
: hide-title
   true

= Conclusion
* PRK Firmware is ((*the world's\nfirst*)) keyboard firmware in Ruby
* ((*`keymap.rb`*)) is the only thing\nyou're gonna deal with
* You can extend your keyboard by\n((*Ruby*))

= ((* *))
(('tag:center'))
(('tag:xx-large'))
Code ((*Ruby*)) with\n
a keyboard that\n
runs on ((*Ruby*))
== prop
: hide-title
   true

= ((* *))
(('tag:center'))
(('tag:xx-large'))
\n
Happy Coding!
== prop
: hide-title
   true

= ((* *))
(('tag:center'))
(('tag:xx-large'))
\n
Thank you!!!q
== prop
: hide-title
   true

